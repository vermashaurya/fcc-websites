<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Friv ‚ù§Ô∏è for my Meethi Lassi</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --ink: #fff5f7;
      --accent: #ff6b88;
      --accent-2: #ffd6a5;
    }

    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(900px 600px at 10% 10%, #1b0b1a 0%, transparent 60%),
                  radial-gradient(700px 500px at 90% 20%, #1b0f0a 0%, transparent 60%),
                  #050208;
      font-family: 'Space Grotesk', system-ui, sans-serif;
      color: var(--ink);
    }

    #overlay {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      color: var(--ink);
      font-size: 1.1rem;
      background: rgba(18, 8, 14, 0.75);
      padding: 16px 26px;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.2);
      z-index: 10;
      backdrop-filter: blur(6px);
      text-align: center;
      letter-spacing: 0.02em;
      box-shadow: 0 16px 30px rgba(0,0,0,0.35);
      transition: opacity 0.4s ease, transform 0.4s ease;
      text-transform: uppercase;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.6rem;
    }

    #overlay .arrows {
      font-size: 1.6rem;
      letter-spacing: 0.15em;
    }

    #overlay.hidden {
      opacity: 0;
      transform: translateX(-50%) translateY(10px);
      pointer-events: none;
    }

    #hud {
      position: fixed;
      left: 24px;
      bottom: 24px;
      z-index: 10;
      background: rgba(8, 5, 10, 0.65);
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 18px;
      padding: 16px 18px;
      max-width: 280px;
      backdrop-filter: blur(6px);
    }

    #hud h2 {
      margin: 0 0 8px 0;
      font-size: 1.1rem;
      color: var(--accent-2);
      letter-spacing: 0.03em;
    }

    #hud p {
      margin: 0;
      font-size: 0.9rem;
      opacity: 0.85;
      line-height: 1.5;
    }

    #memory {
      position: fixed;
      right: 24px;
      bottom: 24px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 18px;
      padding: 16px 18px;
      max-width: 320px;
      backdrop-filter: blur(8px);
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    #memory.active {
      opacity: 1;
      transform: translateY(0);
    }

    #memory h3 {
      margin: 0 0 6px 0;
      font-size: 1rem;
      color: var(--accent);
    }

    #memory p {
      margin: 0;
      font-size: 0.95rem;
      opacity: 0.9;
      line-height: 1.5;
    }

    #finalScene {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      z-index: 20;
      background: radial-gradient(900px 600px at 20% 10%, rgba(255,255,255,0.12) 0%, transparent 60%),
                  radial-gradient(700px 500px at 80% 20%, rgba(255,255,255,0.08) 0%, transparent 60%),
                  rgba(5, 2, 8, 0.85);
      backdrop-filter: blur(6px);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.6s ease;
    }

    #finalScene.active {
      opacity: 1;
      pointer-events: auto;
    }

    #finalScene .final-card {
      max-width: 560px;
      padding: 3.2rem 2.8rem;
      border-radius: 28px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      box-shadow: 0 30px 70px rgba(0,0,0,0.4);
    }

    #finalScene h2 {
      margin: 0 0 0.9rem 0;
      font-size: 2.2rem;
      color: var(--accent-2);
      letter-spacing: 0.02em;
    }

    #finalScene p {
      margin: 0 0 1.6rem 0;
      font-size: 1.05rem;
      line-height: 1.6;
      opacity: 0.9;
    }

    #finalScene .final-question {
      font-size: 1.5rem;
      color: #fff;
      margin-top: 1.2rem;
    }

    #finalScene .final-actions {
      margin-top: 2rem;
      display: flex;
      gap: 1rem;
      justify-content: center;
      flex-wrap: wrap;
      position: relative;
      min-height: 64px;
    }

    #finalScene button {
      border: none;
      padding: 0.9rem 2.4rem;
      border-radius: 999px;
      font-size: 1rem;
      cursor: pointer;
      font-family: 'Space Grotesk', sans-serif;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    #finalScene .yes-btn {
      background: linear-gradient(135deg, #ff6b88, #ffd6a5);
      color: #1b0b1a;
      box-shadow: 0 14px 30px rgba(255, 107, 136, 0.35);
    }

    #finalScene .no-btn {
      background: rgba(255,255,255,0.15);
      color: #fff5f7;
      border: 1px solid rgba(255,255,255,0.3);
    }

    #finalAnswer {
      margin-top: 1.8rem;
      padding: 1.4rem 1.6rem;
      border-radius: 20px;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.2);
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.4s ease, transform 0.4s ease;
    }

    #finalAnswer.active {
      opacity: 1;
      transform: translateY(0);
    }

    @media (max-width: 720px) {
      #hud, #memory { left: 16px; right: 16px; max-width: none; }
      #memory { bottom: 96px; }
      #overlay { bottom: 16px; }
    }
  </style>
</head>
<body>
  <div id="overlay"><span class="arrows">‚¨ÜÔ∏è ‚¨ÖÔ∏è ‚û°Ô∏è</span> Move forward + turn ¬∑ Space jump</div>
  <div id="hud">
    <h2>Interactive Journey</h2>
    <p>Walk forward to relive the little moments. Each sign glows when you're close.</p>
  </div>
  <div id="memory">
    <h3 id="memoryTitle">Memory</h3>
    <p id="memoryText">A tiny moment we shared.</p>
  </div>
  <div id="finalScene">
    <div class="final-card">
      <h2>One last step</h2>
      <p>The path ends here, but what we are is only beginning.</p>
      <div class="final-question">Will you be my Valentine, and keep choosing this story with me?</div>
      <div class="final-actions" id="finalActions">
        <button class="yes-btn" id="finalYes">Yes, always üíû</button>
        <button class="no-btn" id="finalNo">No</button>
      </div>
      <div id="finalAnswer">
        Fer andar ki kar rahi ae? Bahar aa te mainu tight gale lag.
      </div>
    </div>
  </div>
  <audio id="ambientAudio" src="assets/ambient.mp3" preload="auto" loop></audio>
  <audio id="chimeAudio" src="assets/chime.mp3" preload="auto"></audio>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0d050a, 8, 120);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 2.8, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x050208);
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffd7e5, 0.7));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(6, 10, 7);
    scene.add(dirLight);

    const pointLight = new THREE.PointLight(0xff8fb1, 0.9, 60, 2);
    pointLight.position.set(0, 8, -20);
    scene.add(pointLight);

    const groundDepth = 360;
    const edgeZ = -195;
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(320, groundDepth),
      new THREE.MeshStandardMaterial({ color: 0x3a1525, roughness: 0.85, metalness: 0.12 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.z = edgeZ + groundDepth / 2;
    scene.add(ground);

    const avatar = new THREE.Mesh(
      new THREE.BoxGeometry(1, 2, 1),
      new THREE.MeshStandardMaterial({ color: 0xff77aa, emissive: 0x1a050d })
    );
    avatar.position.y = 1;
    avatar.position.z = 10;
    scene.add(avatar);

    const starsGeometry = new THREE.BufferGeometry();
    const starCount = 1600;
    const starPositions = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      const i3 = i * 3;
      starPositions[i3] = (Math.random() - 0.5) * 360;
      starPositions[i3 + 1] = Math.random() * 80 + 10;
      starPositions[i3 + 2] = (Math.random() - 0.5) * 360;
    }
    starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.6, sizeAttenuation: true });
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    const pathLights = [];
    const lightMaterial = new THREE.MeshStandardMaterial({ color: 0xff7aa2, emissive: 0xff3d6d, emissiveIntensity: 1.5 });
    for (let z = 0; z > -220; z -= 8) {
      const light = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), lightMaterial);
      light.position.set(Math.sin(z * 0.1) * 2, 0.6, z);
      scene.add(light);
      pathLights.push(light);
    }

    let walkTime = 0;

    const checkpoints = [
      { z: -8, label: 'Reasons why you should be my Valentine', note: 'Follow the path and let the memories speak.' },
      { z: -48, label: 'Reason 1 ‚ù§Ô∏è', note: 'We look awesome together' },
      { z: -75, label: 'Reason 2 ‚ú®', note: 'The smile I cannot stop cherishing.' },
      { z: -100, label: 'Reason 3 üíï', note: 'You make the world feel softer' },
      { z: -125, label: 'Reason 4 üí´', note: 'The way your hand fits in mine.' }
    ];

    // Replace these with your own photos (place files in journey/assets/)
    const memoryPhotos = [
      'assets/IMG_0006.jpg',
      'assets/IMG_6456.JPG',
      'assets/IMG_6556.jpg',
      'assets/IMG_9981.jpg'
    ];

    const textureLoader = new THREE.TextureLoader();

    let reasonsBoard = null;
    checkpoints.forEach(cp => {
      const mat = new THREE.MeshStandardMaterial({
        color: 0x1a0c14,
        emissive: 0x000000,
        roughness: 0.4,
        metalness: 0.2
      });
      const board = new THREE.Mesh(
        new THREE.PlaneGeometry(12, 5.5),
        mat
      );
      board.position.set(0, 4, cp.z);
      board.userData = { baseZ: cp.z, material: mat, label: cp.label, note: cp.note };
      scene.add(board);
      if (cp.label.startsWith('Reasons')) reasonsBoard = board;
    });

    function makeSignTexture(lines, options = {}) {
      const canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#1a0c14';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#ffd6a5';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const main = lines[0] || '';
      const sub = lines[1] || '';
      const mainSize = options.mainSize || 64;
      const subSize = options.subSize || 42;
      const mainY = options.mainY || (canvas.height / 2 - 36);
      const subY = options.subY || (canvas.height / 2 + 36);
      ctx.font = `${mainSize}px "Space Grotesk", sans-serif`;
      ctx.fillText(main, canvas.width / 2, mainY);
      if (sub) {
        ctx.font = `${subSize}px "Space Grotesk", sans-serif`;
        ctx.fillText(sub, canvas.width / 2, subY);
      }
      const tex = new THREE.CanvasTexture(canvas);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    if (reasonsBoard) {
      reasonsBoard.material.map = makeSignTexture(
        ['Reasons why you should be my', 'Valentine ‚ù§Ô∏è‚ù§Ô∏è'],
        { mainSize: 52, subSize: 72, mainY: 210, subY: 320 }
      );
      reasonsBoard.material.color.setHex(0xffffff);
      reasonsBoard.material.needsUpdate = true;
    }

    // Apply photos to the reason boards (same order as memoryPhotos)
    scene.traverse(obj => {
      if (obj.isMesh && obj.userData?.label?.startsWith('Reason ') ) {
        const memoryIndex = checkpoints.filter(cp => cp.label.startsWith('Reason '))
          .findIndex(cp => cp.label === obj.userData.label);
        const url = memoryPhotos[memoryIndex];
        if (url) {
          textureLoader.load(
            url,
            (tex) => {
              tex.colorSpace = THREE.SRGBColorSpace;
              if (url.toLowerCase().includes('img_9981')) {
                tex.center.set(0.5, 0.5);
                tex.rotation = -Math.PI / 2;
              }
              obj.material.map = tex;
              obj.material.color.setHex(0xffffff);
              obj.material.needsUpdate = true;
            },
            undefined,
            () => {
              console.warn('Failed to load texture:', url);
            }
          );
        }
      }
    });

    const jumpSign = new THREE.Mesh(
      new THREE.PlaneGeometry(10, 4.5),
      new THREE.MeshStandardMaterial({
        color: 0x1a0c14,
        emissive: 0x000000,
        roughness: 0.4,
        metalness: 0.2
      })
    );
    jumpSign.position.set(-2.2, 1.8, edgeZ + 45);
    jumpSign.rotation.y = 0.35;
    jumpSign.userData = {
      material: jumpSign.material,
      label: 'Leap of faith baby ?',
      note: 'The ground ends ahead.'
    };
    jumpSign.material.map = makeSignTexture(['Leap of faith baby ?', 'jump into the void']);
    jumpSign.material.color.setHex(0xffffff);
    jumpSign.material.needsUpdate = true;
    scene.add(jumpSign);

    const keys = {};
    window.addEventListener('keydown', e => keys[e.key] = true);
    window.addEventListener('keyup', e => keys[e.key] = false);

    const speed = 0.30;
    const turnSpeed = 0.05;

    const memoryBox = document.getElementById('memory');
    const memoryTitle = document.getElementById('memoryTitle');
    const memoryText = document.getElementById('memoryText');
    const overlay = document.getElementById('overlay');
    const finalScene = document.getElementById('finalScene');
    const finalYes = document.getElementById('finalYes');
    const finalNo = document.getElementById('finalNo');
    const finalAnswer = document.getElementById('finalAnswer');
    const finalActions = document.getElementById('finalActions');
    const ambientAudio = document.getElementById('ambientAudio');
    const chimeAudio = document.getElementById('chimeAudio');

    const actionsUsed = {
      forward: false,
      backward: false,
      turn: false,
      jump: false
    };

    let hasMoved = false;
    let jumpVelocity = 0;
    let jumpQueued = false;
    let finalTriggered = false;
    let isFalling = false;
    let fallVelocity = 0;
    let lastActiveBoard = null;

    const trailGroup = new THREE.Group();
    scene.add(trailGroup);
    const trailPool = [];
    const trailMax = 70;
    for (let i = 0; i < trailMax; i++) {
      const dot = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xff8fb1, transparent: true, opacity: 0 })
      );
      dot.userData.life = 0;
      trailGroup.add(dot);
      trailPool.push(dot);
    }
    let lastTrailTime = 0;

    function dropTrail() {
      const now = performance.now();
      if (now - lastTrailTime < 70) return;
      lastTrailTime = now;
      const dot = trailPool.find(p => p.userData.life <= 0);
      if (!dot) return;
      dot.position.set(avatar.position.x, avatar.position.y - 0.6, avatar.position.z);
      dot.userData.life = 1;
      dot.material.opacity = 0.9;
    }

    function updateTrail() {
      for (const dot of trailPool) {
        if (dot.userData.life > 0) {
          dot.userData.life -= 0.02;
          dot.material.opacity = Math.max(0, dot.userData.life);
        }
      }
    }

    function unlockAudio() {
      if (ambientAudio) {
        ambientAudio.volume = 0.35;
        ambientAudio.play().catch(() => {});
      }
      window.removeEventListener('keydown', unlockAudio);
      window.removeEventListener('pointerdown', unlockAudio);
      window.removeEventListener('touchstart', unlockAudio);
    }
    window.addEventListener('keydown', unlockAudio);
    window.addEventListener('pointerdown', unlockAudio);
    window.addEventListener('touchstart', unlockAudio);

    function animate() {
      requestAnimationFrame(animate);

      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(avatar.quaternion);

      let moving = false;

      if (!isFalling) {
        if (keys['ArrowUp']) {
          avatar.position.addScaledVector(forward, speed);
          moving = true;
          actionsUsed.forward = true;
        }
        if (keys['ArrowDown']) {
          avatar.position.addScaledVector(forward, -speed * 0.7);
          moving = true;
          actionsUsed.backward = true;
        }

        if (keys['ArrowLeft']) {
          avatar.rotation.y += turnSpeed;
          actionsUsed.turn = true;
        }
        if (keys['ArrowRight']) {
          avatar.rotation.y -= turnSpeed;
          actionsUsed.turn = true;
        }
      }

      const onGround = avatar.position.y <= 1.01;
      if (keys[' '] && onGround && !jumpQueued) {
        jumpVelocity = 0.28;
        jumpQueued = true;
        actionsUsed.jump = true;
      }
      if (!keys[' ']) jumpQueued = false;

      if (jumpVelocity !== 0 || (!onGround && !isFalling)) {
        avatar.position.y += jumpVelocity;
        jumpVelocity -= 0.015;
        if (avatar.position.y <= 1) {
          avatar.position.y = 1;
          jumpVelocity = 0;
        }
      } else if (!isFalling) {
        avatar.position.y += (1 - avatar.position.y) * 0.1;
      }

      if (moving) {
        hasMoved = true;
        dropTrail();
      }

      if (!isFalling && avatar.position.z < edgeZ) {
        isFalling = true;
        fallVelocity = 0;
      }

      if (isFalling) {
        fallVelocity -= 0.02;
        avatar.position.y += fallVelocity;
      }

      let closest = null;
      let closestDist = Infinity;

      scene.traverse(obj => {
        if (obj.isMesh && obj.userData?.material) {
          const dist = avatar.position.distanceTo(obj.position);
          const glow = dist < 12 ? 0x330812 : 0x000000;
          obj.userData.material.emissive.setHex(glow);
          obj.userData.material.emissiveIntensity = dist < 12 ? 0.35 : 0.0;
          if (dist < closestDist) {
            closestDist = dist;
            closest = obj;
          }
        }
      });

      if (closest && closest.userData && closestDist < 12) {
        if (closest === jumpSign || closest === reasonsBoard) {
          memoryBox.classList.remove('active');
        } else {
          memoryTitle.textContent = closest.userData.label;
          memoryText.textContent = closest.userData.note;
          memoryBox.classList.add('active');
          if (closest !== lastActiveBoard && chimeAudio) {
            chimeAudio.currentTime = 0;
            chimeAudio.volume = 0.6;
            chimeAudio.play().catch(() => {});
          }
          lastActiveBoard = closest;
        }
      } else {
        memoryBox.classList.remove('active');
        lastActiveBoard = null;
      }

      camera.position.lerp(
        new THREE.Vector3(
          avatar.position.x - forward.x * 8,
          avatar.position.y + 3.2,
          avatar.position.z - forward.z * 8
        ),
        0.1
      );
      camera.lookAt(avatar.position);

      if (hasMoved) overlay.classList.add('hidden');

      if (!finalTriggered && isFalling && avatar.position.y < -18) {
        finalTriggered = true;
        finalScene.classList.add('active');
      }

      updateTrail();
      renderer.render(scene, camera);
    }

    animate();

    if (finalNo && finalActions) {
      finalNo.style.position = 'relative';

      function dodge() {
        const x = Math.random() * 240 - 120;
        const y = Math.random() * 90 - 45;
        finalNo.style.transform = `translate(${x}px, ${y}px)`;
      }

      finalNo.addEventListener('mouseenter', dodge);

      finalActions.addEventListener('mousemove', (e) => {
        const rect = finalNo.getBoundingClientRect();
        const bx = rect.left + rect.width / 2;
        const by = rect.top + rect.height / 2;
        const dx = e.clientX - bx;
        const dy = e.clientY - by;
        const distance = Math.hypot(dx, dy);
        if (distance < 140) dodge();
      });
    }

    if (finalYes) {
      finalYes.addEventListener('click', () => {
        finalAnswer.classList.add('active');
      });
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
